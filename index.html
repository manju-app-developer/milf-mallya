<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Milf Mallya</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent mobile scrolling */
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .score-board {
            position: absolute;
            top: 10%;
            font-size: 4rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .message-box {
            background: rgba(20, 20, 35, 0.95); /* Darker, cooler background */
            padding: 2.5rem;
            border-radius: 1.5rem;
            text-align: center;
            box-shadow: 0 0 40px rgba(139, 92, 246, 0.4); /* Purple glow */
            border: 2px solid #8b5cf6;
            pointer-events: auto;
            max-width: 85%;
            max-height: 90vh;
            overflow-y: auto;
            color: white;
            transform: scale(1);
            transition: transform 0.2s;
            backdrop-filter: blur(10px);
        }
        .btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
            color: white;
            font-size: 1.2rem;
            font-weight: 800;
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 1rem;
            box-shadow: 0 4px 15px rgba(109, 40, 217, 0.4);
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(109, 40, 217, 0.4);
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="score-display" class="score-board">0</div>

        <div id="ui-layer">
            <!-- Start Screen -->
            <div id="start-screen" class="message-box">
                <h1 class="text-4xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 mb-4">
                    MILF MALLYA ðŸ¤£
                </h1>
                <p class="text-gray-300 text-lg mb-6">Dodge the Face Stacks!</p>
                <p class="text-xs text-gray-500 mb-2 uppercase tracking-widest">Controls</p>
                <p class="text-sm text-gray-400 mb-6 font-mono bg-gray-800 py-2 rounded-lg">Tap â€¢ Click â€¢ Spacebar</p>
                <button class="btn" onclick="startGame()">Start Game</button>
            </div>

            <!-- Game Over Screen -->
            <div id="game-over-screen" class="message-box hidden">
                <h2 class="text-red-500 text-5xl font-black mb-2 drop-shadow-lg">WASTED!</h2>
                <p class="text-gray-300 text-xl mb-4">Score: <span id="final-score" class="text-white font-bold">0</span></p>
                
                <div class="bg-gray-800/50 p-4 rounded-xl border border-gray-700 mb-4">
                    <p id="funny-comment" class="text-lg text-yellow-400 font-bold italic">
                        "Mallya is laughing hard at you..." ðŸ¤£
                    </p>
                </div>

                <!-- Image 3 Displayed Here -->
                <div class="mb-4 flex justify-center">
                    <img src="image3.jpg" alt="Game Over Reaction" class="w-32 h-32 md:w-40 md:h-40 object-cover rounded-full border-4 border-purple-500 shadow-lg">
                </div>
                
                <button class="btn" onclick="resetGame()">Replay ðŸ¤£</button>
            </div>
        </div>
    </div>

    <!-- Image Assets -->
    <img id="block-img-1" src="image.jpg" style="display:none;" alt="The Block 1">
    <img id="block-img-2" src="image2.jpg" style="display:none;" alt="The Block 2">

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreSpan = document.getElementById('final-score');
        const blockImg1 = document.getElementById('block-img-1');
        const blockImg2 = document.getElementById('block-img-2');

        // --- Audio System (Synthesizer) ---
        const SoundController = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            jump: function() {
                this.playTone(400, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(600, 'sine', 0.1, 0.1), 50);
            },
            score: function() {
                this.playTone(1000, 'square', 0.1, 0.05);
                setTimeout(() => this.playTone(1500, 'square', 0.2, 0.05), 50);
            },
            crash: function() {
                this.playTone(150, 'sawtooth', 0.3, 0.2);
                setTimeout(() => this.playTone(100, 'sawtooth', 0.3, 0.2), 100);
            }
        };

        // Game Variables
        let frames = 0;
        let score = 0;
        let currentState = 'START'; 
        let gameSpeed = 3;
        const gravity = 0.25;

        // Stars for background
        const stars = [];
        for(let i=0; i<50; i++) {
            stars.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                size: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.1
            });
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- The Player ---
        const bird = {
            x: 50,
            y: 150,
            radius: 22,
            velocity: 0,
            jump: 4.6,
            rotation: 0,
            
            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                this.rotation = Math.min(Math.PI / 2, Math.max(-Math.PI / 2, (this.velocity * 0.15)));
                ctx.rotate(this.rotation);
                ctx.font = "45px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 10;
                ctx.fillText("ðŸ¤£", 0, 4); 
                ctx.restore();
            },
            
            update: function() {
                this.velocity += gravity;
                this.y += this.velocity;

                if (this.y + this.radius >= canvas.height - fg.h) {
                    this.y = canvas.height - fg.h - this.radius;
                    gameOver();
                }
                
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0;
                }
            },
            
            flap: function() {
                this.velocity = -this.jump;
                SoundController.jump();
            }
        };

        // --- Better Background ---
        const bg = {
            draw: function() {
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, "#0f172a");
                gradient.addColorStop(0.5, "#1e1b4b");
                gradient.addColorStop(1, "#312e81");
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = "white";
                stars.forEach(star => {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
                    ctx.fill();
                    
                    if(currentState === 'PLAYING') {
                        star.x -= star.speed; 
                        if(star.x < 0) star.x = canvas.width;
                    }
                });
            }
        };

        // --- Foreground ---
        const fg = {
            h: 50,
            x: 0,
            draw: function() {
                ctx.fillStyle = "#020617"; 
                ctx.fillRect(this.x, canvas.height - this.h, canvas.width, this.h);
                ctx.fillRect(this.x + canvas.width, canvas.height - this.h, canvas.width, this.h);
                
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - this.h);
                ctx.lineTo(canvas.width, canvas.height - this.h);
                ctx.strokeStyle = "#a855f7"; 
                ctx.lineWidth = 4;
                ctx.shadowColor = "#a855f7";
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0; 
            },
            update: function() {
                this.x = (this.x - gameSpeed) % (canvas.width / 2);
            }
        };

        // --- Pipes ---
        const pipes = {
            position: [],
            w: 80,
            h: 150,
            gap: 170,
            
            draw: function() {
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    let topY = p.y;
                    let bottomY = p.y + this.h + this.gap;
                    
                    // Determine which image to use based on the pipe property
                    let imgToUse = p.variant === 0 ? blockImg1 : blockImg2;

                    this.drawFaceBlock(p.x, 0, this.w, topY + this.h, imgToUse);
                    this.drawFaceBlock(p.x, bottomY, this.w, canvas.height - bottomY - fg.h, imgToUse);
                }
            },

            drawFaceBlock: function(x, y, w, h, imgEl) {
                let ratio = 1.77;
                // Check if specific image is loaded, otherwise fallback
                if (imgEl && imgEl.complete && imgEl.naturalWidth > 0) {
                    ratio = imgEl.naturalHeight / imgEl.naturalWidth;
                }
                const imgH = w * ratio; 
                
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.clip(); 

                ctx.fillStyle = "#334155"; 
                ctx.fillRect(x, y, w, h);

                for (let currY = y; currY < y + h; currY += imgH) {
                    if (imgEl && imgEl.complete && imgEl.naturalWidth > 0) {
                        ctx.drawImage(imgEl, x, currY, w, imgH);
                    }
                }
                
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, w, h);
                ctx.restore();
            },
            
            update: function() {
                if (frames % 120 === 0) {
                    // Assign variant 0 or 1 alternatingly based on count or random
                    // Using frame count to alternate predictably
                    let variant = (frames / 120) % 2 === 0 ? 0 : 1;
                    
                    this.position.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - fg.h - this.gap - 200) - 50,
                        variant: variant
                    });
                }
                
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    p.x -= gameSpeed; 
                    
                    let hitboxPadding = 5;
                    let birdLeft = bird.x - bird.radius + hitboxPadding;
                    let birdRight = bird.x + bird.radius - hitboxPadding;
                    let birdTop = bird.y - bird.radius + hitboxPadding;
                    let birdBottom = bird.y + bird.radius - hitboxPadding;
                    
                    let pipeLeft = p.x;
                    let pipeRight = p.x + this.w;
                    let topPipeBottom = p.y + this.h;
                    let bottomPipeTop = p.y + this.h + this.gap;
                    
                    // Collision
                    if (birdRight > pipeLeft && birdLeft < pipeRight && birdTop < topPipeBottom) gameOver();
                    if (birdRight > pipeLeft && birdLeft < pipeRight && birdBottom > bottomPipeTop) gameOver();
                    
                    // Score
                    if (p.x + this.w < bird.x - bird.radius && !p.passed) {
                        score++;
                        p.passed = true;
                        scoreDisplay.innerText = score;
                        SoundController.score();
                        if(score % 5 === 0) gameSpeed += 0.2;
                    }
                    
                    if (p.x + this.w <= 0) {
                        this.position.shift();
                        i--; 
                    }
                }
            },
            
            reset: function() {
                this.position = [];
            }
        };

        // --- Logic ---

        function startGame() {
            SoundController.init(); // Initialize audio context on user interaction
            if(SoundController.ctx.state === 'suspended') {
                SoundController.ctx.resume();
            }

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreDisplay.classList.remove('hidden');
            currentState = 'PLAYING';
            score = 0;
            frames = 0;
            gameSpeed = 3;
            scoreDisplay.innerText = score;
            
            bird.y = 150;
            bird.velocity = 0;
            pipes.reset();
            
            loop();
        }

        function resetGame() {
            startGame();
        }

        function gameOver() {
            if(currentState !== 'GAMEOVER') {
                SoundController.crash();
                currentState = 'GAMEOVER';
                finalScoreSpan.innerText = score;
                scoreDisplay.classList.add('hidden');
                gameOverScreen.classList.remove('hidden');
            }
        }

        function loop() {
            if (currentState !== 'PLAYING') return;
            
            bg.draw();
            pipes.update();
            pipes.draw();
            fg.update(); 
            fg.draw();  
            bird.update();
            bird.draw();
            
            frames++;
            requestAnimationFrame(loop);
        }
        
        // Initial Render
        bg.draw();
        fg.draw();
        bird.draw();

        window.addEventListener("keydown", function(e) {
            if (e.code === "Space" || e.code === "ArrowUp") {
                if(currentState === 'PLAYING') bird.flap();
                else if(currentState !== 'PLAYING' && !startScreen.classList.contains('hidden')) startGame();
            }
        });
        
        window.addEventListener("mousedown", function(e) {
            if (e.target.tagName === 'BUTTON') return;
            if(currentState === 'PLAYING') bird.flap();
        });
        
        window.addEventListener("touchstart", function(e) {
            if (e.target.tagName === 'BUTTON') return;
            if(currentState === 'PLAYING') bird.flap();
        }, {passive: false});

    </script>
</body>
</html>



            <!-- Game Over Screen -->
            <div id="game-over-screen" class="message-box hidden">
                <h2 class="text-red-500 text-5xl font-black mb-2 drop-shadow-lg">WASTED!</h2>
                <p class="text-gray-300 text-xl mb-4">Score: <span id="final-score" class="text-white font-bold">0</span></p>
                
                <div class="bg-gray-800/50 p-4 rounded-xl border border-gray-700 mb-4">
                    <p id="funny-comment" class="text-lg text-yellow-400 font-bold italic">
                        "Mallya is laughing hard at you..." ðŸ¤£
                    </p>
                </div>

                <!-- Image 3 Displayed Here -->
                <div class="mb-4 flex justify-center">
                    <img src="image3.jpg" alt="Game Over Reaction" class="w-32 h-32 md:w-40 md:h-40 object-cover rounded-full border-4 border-purple-500 shadow-lg">
                </div>
                
                <button class="btn" onclick="resetGame()">Replay ðŸ¤£</button>
            </div>
        </div>
    </div>

    <!-- Image Assets -->
    <img id="block-img-1" src="image.jpg" style="display:none;" alt="The Block 1">
    <img id="block-img-2" src="image2.jpg" style="display:none;" alt="The Block 2">

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreSpan = document.getElementById('final-score');
        const blockImg1 = document.getElementById('block-img-1');
        const blockImg2 = document.getElementById('block-img-2');

        // --- Audio System (Synthesizer) ---
        const SoundController = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            jump: function() {
                this.playTone(400, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(600, 'sine', 0.1, 0.1), 50);
            },
            score: function() {
                this.playTone(1000, 'square', 0.1, 0.05);
                setTimeout(() => this.playTone(1500, 'square', 0.2, 0.05), 50);
            },
            crash: function() {
                this.playTone(150, 'sawtooth', 0.3, 0.2);
                setTimeout(() => this.playTone(100, 'sawtooth', 0.3, 0.2), 100);
            }
        };

        // Game Variables
        let frames = 0;
        let score = 0;
        let currentState = 'START'; 
        let gameSpeed = 3;
        const gravity = 0.25;

        // Stars for background
        const stars = [];
        for(let i=0; i<50; i++) {
            stars.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                size: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.1
            });
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- The Player ---
        const bird = {
            x: 50,
            y: 150,
            radius: 22,
            velocity: 0,
            jump: 4.6,
            rotation: 0,
            
            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                this.rotation = Math.min(Math.PI / 2, Math.max(-Math.PI / 2, (this.velocity * 0.15)));
                ctx.rotate(this.rotation);
                ctx.font = "45px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 10;
                ctx.fillText("ðŸ¤£", 0, 4); 
                ctx.restore();
            },
            
            update: function() {
                this.velocity += gravity;
                this.y += this.velocity;

                if (this.y + this.radius >= canvas.height - fg.h) {
                    this.y = canvas.height - fg.h - this.radius;
                    gameOver();
                }
                
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0;
                }
            },
            
            flap: function() {
                this.velocity = -this.jump;
                SoundController.jump();
            }
        };

        // --- Better Background ---
        const bg = {
            draw: function() {
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, "#0f172a");
                gradient.addColorStop(0.5, "#1e1b4b");
                gradient.addColorStop(1, "#312e81");
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = "white";
                stars.forEach(star => {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
                    ctx.fill();
                    
                    if(currentState === 'PLAYING') {
                        star.x -= star.speed; 
                        if(star.x < 0) star.x = canvas.width;
                    }
                });
            }
        };

        // --- Foreground ---
        const fg = {
            h: 50,
            x: 0,
            draw: function() {
                ctx.fillStyle = "#020617"; 
                ctx.fillRect(this.x, canvas.height - this.h, canvas.width, this.h);
                ctx.fillRect(this.x + canvas.width, canvas.height - this.h, canvas.width, this.h);
                
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - this.h);
                ctx.lineTo(canvas.width, canvas.height - this.h);
                ctx.strokeStyle = "#a855f7"; 
                ctx.lineWidth = 4;
                ctx.shadowColor = "#a855f7";
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0; 
            },
            update: function() {
                this.x = (this.x - gameSpeed) % (canvas.width / 2);
            }
        };

        // --- Pipes ---
        const pipes = {
            position: [],
            w: 80,
            h: 150,
            gap: 170,
            
            draw: function() {
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    let topY = p.y;
                    let bottomY = p.y + this.h + this.gap;
                    
                    // Determine which image to use based on the pipe property
                    let imgToUse = p.variant === 0 ? blockImg1 : blockImg2;

                    this.drawFaceBlock(p.x, 0, this.w, topY + this.h, imgToUse);
                    this.drawFaceBlock(p.x, bottomY, this.w, canvas.height - bottomY - fg.h, imgToUse);
                }
            },

            drawFaceBlock: function(x, y, w, h, imgEl) {
                let ratio = 1.77;
                // Check if specific image is loaded, otherwise fallback
                if (imgEl && imgEl.complete && imgEl.naturalWidth > 0) {
                    ratio = imgEl.naturalHeight / imgEl.naturalWidth;
                }
                const imgH = w * ratio; 
                
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.clip(); 

                ctx.fillStyle = "#334155"; 
                ctx.fillRect(x, y, w, h);

                for (let currY = y; currY < y + h; currY += imgH) {
                    if (imgEl && imgEl.complete && imgEl.naturalWidth > 0) {
                        ctx.drawImage(imgEl, x, currY, w, imgH);
                    }
                }
                
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, w, h);
                ctx.restore();
            },
            
            update: function() {
                if (frames % 120 === 0) {
                    // Assign variant 0 or 1 alternatingly based on count or random
                    // Using frame count to alternate predictably
                    let variant = (frames / 120) % 2 === 0 ? 0 : 1;
                    
                    this.position.push({
                        x: canvas.width,
                        y: Math.random() * (canvas.height - fg.h - this.gap - 200) - 50,
                        variant: variant
                    });
                }
                
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    p.x -= gameSpeed; 
                    
                    let hitboxPadding = 5;
                    let birdLeft = bird.x - bird.radius + hitboxPadding;
                    let birdRight = bird.x + bird.radius - hitboxPadding;
                    let birdTop = bird.y - bird.radius + hitboxPadding;
                    let birdBottom = bird.y + bird.radius - hitboxPadding;
                    
                    let pipeLeft = p.x;
                    let pipeRight = p.x + this.w;
                    let topPipeBottom = p.y + this.h;
                    let bottomPipeTop = p.y + this.h + this.gap;
                    
                    // Collision
                    if (birdRight > pipeLeft && birdLeft < pipeRight && birdTop < topPipeBottom) gameOver();
                    if (birdRight > pipeLeft && birdLeft < pipeRight && birdBottom > bottomPipeTop) gameOver();
                    
                    // Score
                    if (p.x + this.w < bird.x - bird.radius && !p.passed) {
                        score++;
                        p.passed = true;
                        scoreDisplay.innerText = score;
                        SoundController.score();
                        if(score % 5 === 0) gameSpeed += 0.2;
                    }
                    
                    if (p.x + this.w <= 0) {
                        this.position.shift();
                        i--; 
                    }
                }
            },
            
            reset: function() {
                this.position = [];
            }
        };

        // --- Logic ---

        function startGame() {
            SoundController.init(); // Initialize audio context on user interaction
            if(SoundController.ctx.state === 'suspended') {
                SoundController.ctx.resume();
            }

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreDisplay.classList.remove('hidden');
            currentState = 'PLAYING';
            score = 0;
            frames = 0;
            gameSpeed = 3;
            scoreDisplay.innerText = score;
            
            bird.y = 150;
            bird.velocity = 0;
            pipes.reset();
            
            loop();
        }

        function resetGame() {
            startGame();
        }

        function gameOver() {
            if(currentState !== 'GAMEOVER') {
                SoundController.crash();
                currentState = 'GAMEOVER';
                finalScoreSpan.innerText = score;
                scoreDisplay.classList.add('hidden');
                gameOverScreen.classList.remove('hidden');
            }
        }

        function loop() {
            if (currentState !== 'PLAYING') return;
            
            bg.draw();
            pipes.update();
            pipes.draw();
            fg.update(); 
            fg.draw();  
            bird.update();
            bird.draw();
            
            frames++;
            requestAnimationFrame(loop);
        }
        
        // Initial Render
        bg.draw();
        fg.draw();
        bird.draw();

        window.addEventListener("keydown", function(e) {
            if (e.code === "Space" || e.code === "ArrowUp") {
                if(currentState === 'PLAYING') bird.flap();
                else if(currentState !== 'PLAYING' && !startScreen.classList.contains('hidden')) startGame();
            }
        });
        
        window.addEventListener("mousedown", function(e) {
            if (e.target.tagName === 'BUTTON') return;
            if(currentState === 'PLAYING') bird.flap();
        });
        
        window.addEventListener("touchstart", function(e) {
            if (e.target.tagName === 'BUTTON') return;
            if(currentState === 'PLAYING') bird.flap();
        }, {passive: false});

    </script>
</body>
</html>


